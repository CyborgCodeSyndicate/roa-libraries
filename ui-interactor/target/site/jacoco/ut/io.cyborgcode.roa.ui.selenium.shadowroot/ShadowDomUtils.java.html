<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ShadowDomUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Ring of Automation UI Library</a> &gt; <a href="index.source.html" class="el_package">io.cyborgcode.roa.ui.selenium.shadowroot</a> &gt; <span class="el_source">ShadowDomUtils.java</span></div><h1>ShadowDomUtils.java</h1><pre class="source lang-java linenums">package io.cyborgcode.roa.ui.selenium.shadowroot;

import io.cyborgcode.roa.ui.selenium.exceptions.UiInteractionException;
import io.cyborgcode.roa.ui.selenium.smart.SmartWebDriver;
import io.cyborgcode.roa.ui.selenium.smart.SmartWebElement;
import java.util.Map;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import static io.cyborgcode.roa.ui.config.UiConfigHolder.getUiConfig;

/**
 * Utility class for interacting with Shadow DOM elements using Selenium.
 * Provides methods to locate elements within Shadow Roots, including
 * support for waiting and polling mechanisms.
 *
 * @author Cyborg Code Syndicate üíçüë®üíª
 */
public class ShadowDomUtils {

   /**
    * Default polling interval in milliseconds if not explicitly specified.
    */
   private static final long DEFAULT_POLL_INTERVAL_MS = 500;
   private static final String VALUE = &quot;value&quot;;
   private static final String MAX_WAIT = &quot;maxWait&quot;;
   private static final String POLL_INTERVAL = &quot;pollInterval&quot;;

   private ShadowDomUtils() {
   }

   /**
    * Converts a Selenium {@code By} locator into a map representation.
    * This is used by JavaScript scripts for element searching.
    *
    * @param by Selenium {@code By} locator.
    * @return A map containing the locator type and value.
    * @throws IllegalArgumentException if an unsupported locator type is used.
    */
   private static Map&lt;String, Object&gt; parseBy(By by) {
<span class="fc" id="L43">      String asString = by.toString(); // e.g. &quot;By.id: username&quot;</span>

<span class="fc bfc" id="L45" title="All 2 branches covered.">      if (asString.startsWith(&quot;By.id: &quot;)) {</span>
<span class="fc" id="L46">         return Map.of(&quot;type&quot;, &quot;id&quot;,</span>
<span class="fc" id="L47">               VALUE, asString.substring(&quot;By.id: &quot;.length()).trim());</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.name: &quot;)) {</span>
<span class="fc" id="L49">         return Map.of(&quot;type&quot;, &quot;name&quot;,</span>
<span class="fc" id="L50">               VALUE, asString.substring(&quot;By.name: &quot;.length()).trim());</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.className: &quot;)) {</span>
<span class="fc" id="L52">         return Map.of(&quot;type&quot;, &quot;className&quot;,</span>
<span class="fc" id="L53">               VALUE, asString.substring(&quot;By.className: &quot;.length()).trim());</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.cssSelector: &quot;)) {</span>
<span class="fc" id="L55">         return Map.of(&quot;type&quot;, &quot;css&quot;,</span>
<span class="fc" id="L56">               VALUE, asString.substring(&quot;By.cssSelector: &quot;.length()).trim());</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.tagName: &quot;)) {</span>
<span class="fc" id="L58">         return Map.of(&quot;type&quot;, &quot;tagName&quot;,</span>
<span class="fc" id="L59">               VALUE, asString.substring(&quot;By.tagName: &quot;.length()).trim());</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.linkText: &quot;)) {</span>
<span class="fc" id="L61">         return Map.of(&quot;type&quot;, &quot;linkText&quot;,</span>
<span class="fc" id="L62">               VALUE, asString.substring(&quot;By.linkText: &quot;.length()).trim());</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.partialLinkText: &quot;)) {</span>
<span class="fc" id="L64">         return Map.of(&quot;type&quot;, &quot;partialLinkText&quot;,</span>
<span class="fc" id="L65">               VALUE, asString.substring(&quot;By.partialLinkText: &quot;.length()).trim());</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">      } else if (asString.startsWith(&quot;By.xpath: &quot;)) {</span>
<span class="fc" id="L67">         throw new IllegalArgumentException(</span>
               &quot;Xpath selectors are not supported inside shadow roots. Please change your xpath selector: &quot;
                     + asString + &quot;to any other selenium supported selector&quot;);
      } else {
<span class="fc" id="L71">         throw new IllegalArgumentException(&quot;Unsupported By type: &quot; + asString);</span>
      }
   }

   // -------------------------------------------------------------------------------------------
   // 1) SCRIPTS FOR FINDING A SINGLE ELEMENT (with optional in-JS waiting)
   // -------------------------------------------------------------------------------------------

   /**
    * JavaScript function to locate a single shadow DOM element.
    * The script searches for elements inside shadow roots and supports
    * different locator strategies such as id, name, class, CSS, tag name,
    * link text, and partial link text. XPath is not supported within shadow DOMs.
    */
   private static final String FIND_SHADOW_ELEMENT_JS = &quot;&quot;&quot;
         function findShadowElement(params) {
           const type = params.type;
           const value = params.value;
           const maxWait = params.maxWait || 10000;
           const pollInterval = params.pollInterval || 500;
         
           function findInRoot(root, type, value) {
             switch (type) {
               case 'id':
                 return root.querySelector('#' + value);
               case 'name':
                 return root.querySelector('[name=&quot;' + value + '&quot;]');
               case 'className':
                 var classes = value.trim().split(/\\s+/).join('.');
                 return root.querySelector('.' + classes);
               case 'css':
                 return root.querySelector(value);
               case 'tagName':
                 return root.querySelector(value);
               case 'xpath':
                 return document.evaluate(
                   value,
                   root,
                   null,
                   XPathResult.FIRST_ORDERED_NODE_TYPE,
                   null
                 ).singleNodeValue;
               case 'linkText':
                 var anchors = root.querySelectorAll('a');
                 for (var i = 0; i &lt; anchors.length; i++) {
                   if (anchors[i].textContent === value) {
                     return anchors[i];
                   }
                 }
                 return null;
               case 'partialLinkText':
                 var anchors2 = root.querySelectorAll('a');
                 for (var j = 0; j &lt; anchors2.length; j++) {
                   if (anchors2[j].textContent.includes(value)) {
                     return anchors2[j];
                   }
                 }
                 return null;
               default:
                 return null;
             }
           }
         
           function searchShadow(rootNodes, type, value) {
             for (var i = 0; i &lt; rootNodes.length; i++) {
               var node = rootNodes[i];
               if (node &amp;&amp; node.shadowRoot) {
                 var found = findInRoot(node.shadowRoot, type, value);
                 if (found) {
                   return found;
                 }
                 // Recurse deeper
                 var deeper = searchShadow(node.shadowRoot.querySelectorAll('*'), type, value);
                 if (deeper) {
                   return deeper;
                 }
               }
             }
             return null;
           }
         
           const startTime = performance.now();
           while ((performance.now() - startTime) &lt; maxWait) {
             // 1) Try main document
             var direct = findInRoot(document, type, value);
             if (direct) {
               return direct;
             }
             // 2) Search shadow
             var all = document.querySelectorAll('*');
             var shadowFound = searchShadow(all, type, value);
             if (shadowFound) {
               return shadowFound;
             }
             // 3) Wait/poll
             var now = performance.now();
             while (performance.now() - now &lt; pollInterval) {
               // busy wait - will block the page
             }
           }
           return null; // not found
         }
         return findShadowElement(arguments[0]);
         &quot;&quot;&quot;;


   /**
    * Finds the first matching element across the entire document, including nested shadow roots.
    * Waits up to the default timeout duration, polling at defined intervals.
    *
    * @param driver The {@link SmartWebDriver} instance.
    * @param by     The {@link By} locator to use.
    * @return The found {@link SmartWebElement}, or null if not found.
    */
   public static SmartWebElement findElementInShadowRoots(SmartWebDriver driver, By by) {
<span class="fc" id="L186">      long wait = getUiConfig().waitDuration()</span>
            * 1000L;
<span class="fc" id="L188">      return findElementInShadowRoots(driver, by, wait);</span>
   }

   /**
    * Finds the first matching element across the document and nested shadow roots with a specified timeout.
    *
    * @param driver       The {@link SmartWebDriver} instance.
    * @param by           The {@link By} locator.
    * @param waitInMillis Maximum wait time in milliseconds.
    * @return The found {@link SmartWebElement}, or null if not found.
    */
   public static SmartWebElement findElementInShadowRoots(SmartWebDriver driver, By by, long waitInMillis) {
<span class="fc" id="L200">      JavascriptExecutor js = (JavascriptExecutor) driver.getOriginal();</span>
<span class="fc" id="L201">      Map&lt;String, Object&gt; selector = parseBy(by);</span>

<span class="fc" id="L203">      selector = new java.util.HashMap&lt;&gt;(selector);</span>
<span class="fc" id="L204">      selector.put(MAX_WAIT, waitInMillis);</span>
<span class="fc" id="L205">      selector.put(POLL_INTERVAL, DEFAULT_POLL_INTERVAL_MS);</span>

<span class="fc" id="L207">      WebElement element = (WebElement) js.executeScript(FIND_SHADOW_ELEMENT_JS, selector);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">      if (element == null) {</span>
<span class="fc" id="L209">         throw new UiInteractionException(&quot;Finding element in shadow root via java script failed&quot;);</span>
      }

<span class="fc" id="L212">      return new SmartWebElement(element, driver.getOriginal());</span>
   }

   /**
    * Finds the first matching element in nested Shadow DOMs, starting from a given root element.
    * Waits up to the configured maximum wait time, polling every {@code DEFAULT_POLL_INTERVAL_MS}.
    *
    * @param root The root {@link SmartWebElement} to start the search from.
    * @param by   The {@link By} locator to use for finding the element.
    * @return The found {@link SmartWebElement}, or {@code null} if no element is found within the time limit.
    */
   public static SmartWebElement findElementInShadowRoots(SmartWebElement root, By by) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">      if (root == null) {</span>
<span class="fc" id="L225">         return null;</span>
      }
<span class="fc" id="L227">      WebDriver driver = root.getDriver();</span>
<span class="fc" id="L228">      JavascriptExecutor js = (JavascriptExecutor) driver;</span>

<span class="fc" id="L230">      Map&lt;String, Object&gt; selector = parseBy(by);</span>
<span class="fc" id="L231">      selector = new java.util.HashMap&lt;&gt;(selector);</span>
<span class="fc" id="L232">      long wait = getUiConfig().waitDuration() * 1000L;</span>
<span class="fc" id="L233">      selector.put(MAX_WAIT, wait);</span>
<span class="fc" id="L234">      selector.put(POLL_INTERVAL, DEFAULT_POLL_INTERVAL_MS);</span>

<span class="fc" id="L236">      WebElement element = (WebElement) js.executeScript(FIND_SHADOW_ELEMENT_FROM_ELEMENT_JS, root.getOriginal(),</span>
            selector);
<span class="fc bfc" id="L238" title="All 2 branches covered.">      if (element == null) {</span>
<span class="fc" id="L239">         throw new UiInteractionException(&quot;Finding element in shadow root via java script failed&quot;);</span>
      }

<span class="fc" id="L242">      return new SmartWebElement(element, driver);</span>
   }

   /**
    * JavaScript function to locate a single shadow DOM element.
    * The script searches for elements inside shadow roots and supports
    * different locator strategies such as id, name, class, CSS, tag name,
    * link text, and partial link text. XPath is not supported within shadow DOMs.
    */
   private static final String FIND_SHADOW_ELEMENT_FROM_ELEMENT_JS = &quot;&quot;&quot;
         function findShadowElementFromRoot(rootElem, params) {
           const type = params.type;
           const value = params.value;
           const maxWait = params.maxWait || 10000;
           const pollInterval = params.pollInterval || 500;
         
           function findInRoot(root, type, value) {
             // same approach as above
             switch (type) {
               case 'id':
                 return root.querySelector('#' + value);
               case 'name':
                 return root.querySelector('[name=&quot;' + value + '&quot;]');
               case 'className':
                 var classes = value.trim().split(/\\s+/).join('.');
                 return root.querySelector('.' + classes);
               case 'css':
                 return root.querySelector(value);
               case 'tagName':
                 return root.querySelector(value);
               case 'xpath':
                 return document.evaluate(value, root, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
               case 'linkText':
                 var anchors = root.querySelectorAll('a');
                 for (var i = 0; i &lt; anchors.length; i++) {
                   if (anchors[i].textContent === value) {
                     return anchors[i];
                   }
                 }
                 return null;
               case 'partialLinkText':
                 var anchors2 = root.querySelectorAll('a');
                 for (var j = 0; j &lt; anchors2.length; j++) {
                   if (anchors2[j].textContent.includes(value)) {
                     return anchors2[j];
                   }
                 }
                 return null;
               default:
                 return null;
             }
           }
         
           function searchShadow(rootNodes, type, value) {
             for (var i = 0; i &lt; rootNodes.length; i++) {
               var node = rootNodes[i];
               if (node &amp;&amp; node.shadowRoot) {
                 var found = findInRoot(node.shadowRoot, type, value);
                 if (found) {
                   return found;
                 }
                 var deeper = searchShadow(node.shadowRoot.querySelectorAll('*'), type, value);
                 if (deeper) {
                   return deeper;
                 }
               }
             }
             return null;
           }
         
           const startTime = performance.now();
           while ((performance.now() - startTime) &lt; maxWait) {
             // 1) if rootElem itself has a shadowRoot
             if (rootElem.shadowRoot) {
               var shadowDirect = findInRoot(rootElem.shadowRoot, type, value);
               if (shadowDirect) {
                 return shadowDirect;
               }
               var shadowDeep = searchShadow(rootElem.shadowRoot.querySelectorAll('*'), type, value);
               if (shadowDeep) {
                 return shadowDeep;
               }
             }
         
             // 2) check rootElem itself as a normal DOM container
             var direct = findInRoot(rootElem, type, value);
             if (direct) {
               return direct;
             }
         
             // 3) check children shadow roots
             var children = rootElem.querySelectorAll('*');
             var deeper = searchShadow(children, type, value);
             if (deeper) {
               return deeper;
             }
         
             // 4) poll
             var now = performance.now();
             while (performance.now() - now &lt; pollInterval) {
               // busy wait
             }
           }
           return null;
         }
         return findShadowElementFromRoot(arguments[0], arguments[1]);
         &quot;&quot;&quot;;

   // -------------------------------------------------------------------------------------------
   // 2) SCRIPTS FOR FINDING MULTIPLE ELEMENTS + WAIT
   // -------------------------------------------------------------------------------------------

   /**
    * JavaScript function to find all matching elements within Shadow DOMs.
    * The script recursively searches the main document and any shadow roots
    * for elements that match the given selector. The results are collected
    * and returned as an array of matching elements.
    */
   private static final String FIND_SHADOW_ELEMENTS_JS = &quot;&quot;&quot;
         function findShadowElements(params) {
           const type = params.type;
           const value = params.value;
           const maxWait = params.maxWait || 10000;
           const pollInterval = params.pollInterval || 500;
         
           // We'll collect all matches in an array.
           function collectInRoot(root, type, value) {
             let nodeList = [];
             switch (type) {
               case 'id':
                 let elById = root.querySelector('#' + value);
                 if (elById) nodeList.push(elById);
                 break;
               case 'name':
                 nodeList = root.querySelectorAll('[name=&quot;' + value + '&quot;]');
                 break;
               case 'className':
                 var classes = value.trim().split(/\\s+/).join('.');
                 nodeList = root.querySelectorAll('.' + classes);
                 break;
               case 'css':
                 nodeList = root.querySelectorAll(value);
                 break;
               case 'tagName':
                 nodeList = root.querySelectorAll(value);
                 break;
               case 'xpath':
                 let xresult = document.evaluate(value, root, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                 for (let i = 0; i &lt; xresult.snapshotLength; i++) {
                   nodeList.push(xresult.snapshotItem(i));
                 }
                 break;
               case 'linkText':
                 let allAnchors = root.querySelectorAll('a');
                 allAnchors.forEach(a =&gt; {
                   if (a.textContent === value) nodeList.push(a);
                 });
                 break;
               case 'partialLinkText':
                 let anchors2 = root.querySelectorAll('a');
                 anchors2.forEach(a =&gt; {
                   if (a.textContent.includes(value)) nodeList.push(a);
                 });
                 break;
             }
             return Array.from(nodeList);
           }
         
           function collectShadow(rootNodes, type, value, results) {
             for (var i = 0; i &lt; rootNodes.length; i++) {
               var node = rootNodes[i];
               if (node &amp;&amp; node.shadowRoot) {
                 // collect in this shadow root
                 results.push(...collectInRoot(node.shadowRoot, type, value));
                 // go deeper
                 collectShadow(node.shadowRoot.querySelectorAll('*'), type, value, results);
               }
             }
           }
         
           function doSearch() {
             let found = [];
             // 1) main document
             found.push(...collectInRoot(document, type, value));
             // 2) shadow
             let all = document.querySelectorAll('*');
             collectShadow(all, type, value, found);
             return found;
           }
         
           const startTime = performance.now();
           while ((performance.now() - startTime) &lt; maxWait) {
             let result = doSearch();
             if (result.length &gt; 0) {
               return result; // return array of elements
             }
             // poll
             var now = performance.now();
             while (performance.now() - now &lt; pollInterval) {
               // busy wait
             }
           }
           return [];
         }
         return findShadowElements(arguments[0]);
         &quot;&quot;&quot;;

   /**
    * Finds all matching elements across the document and nested shadow roots.
    * Waits up to the configured maximum wait time, polling every {@code DEFAULT_POLL_INTERVAL_MS}.
    *
    * @param driver The {@link SmartWebDriver} instance.
    * @param by     The {@link By} locator to use for finding the elements.
    * @return A list of {@link SmartWebElement} containing all matching elements, or an empty list if no elements
    *       are found.
    */
   public static java.util.List&lt;SmartWebElement&gt; findElementsInShadowRoots(SmartWebDriver driver, By by) {
<span class="fc" id="L459">      JavascriptExecutor js = (JavascriptExecutor) driver.getOriginal();</span>

<span class="fc" id="L461">      Map&lt;String, Object&gt; selector = parseBy(by);</span>
<span class="fc" id="L462">      selector = new java.util.HashMap&lt;&gt;(selector);</span>
<span class="fc" id="L463">      long wait = getUiConfig().waitDuration() * 1000L;</span>
<span class="fc" id="L464">      selector.put(MAX_WAIT, wait);</span>
<span class="fc" id="L465">      selector.put(POLL_INTERVAL, DEFAULT_POLL_INTERVAL_MS);</span>

<span class="fc" id="L467">      Object result = js.executeScript(FIND_SHADOW_ELEMENTS_JS, selector);</span>
      // The returned object should be a List&lt;RemoteWebElement&gt; if found
<span class="fc bfc" id="L469" title="All 2 branches covered.">      if (result instanceof java.util.List) {</span>
<span class="fc" id="L470">         return ((java.util.List&lt;WebElement&gt;) result).stream()</span>
<span class="fc" id="L471">               .map(webElement -&gt; new SmartWebElement(webElement, driver.getOriginal())).toList();</span>
      }
      // otherwise return empty
<span class="fc" id="L474">      return java.util.Collections.emptyList();</span>
   }

   /**
    * Finds all matching elements within a given Shadow DOM root.
    * Waits up to the configured maximum wait time, polling every {@code DEFAULT_POLL_INTERVAL_MS}.
    *
    * @param root The root {@link SmartWebElement} to start the search from.
    * @param by   The {@link By} locator to use for finding the elements.
    * @return A list of {@link SmartWebElement} containing all matching elements, or an empty list if no elements
    *       are found.
    */
   public static java.util.List&lt;SmartWebElement&gt; findElementsInShadowRoots(SmartWebElement root, By by) {
<span class="fc bfc" id="L487" title="All 2 branches covered.">      if (root == null) {</span>
<span class="fc" id="L488">         return java.util.Collections.emptyList();</span>
      }
<span class="fc" id="L490">      WebDriver driver = root.getDriver();</span>
<span class="fc" id="L491">      JavascriptExecutor js = (JavascriptExecutor) driver;</span>

<span class="fc" id="L493">      Map&lt;String, Object&gt; selector = parseBy(by);</span>
<span class="fc" id="L494">      selector = new java.util.HashMap&lt;&gt;(selector);</span>
<span class="fc" id="L495">      long wait = getUiConfig().waitDuration() * 1000L;</span>
<span class="fc" id="L496">      selector.put(MAX_WAIT, wait);</span>
<span class="fc" id="L497">      selector.put(POLL_INTERVAL, DEFAULT_POLL_INTERVAL_MS);</span>

<span class="fc" id="L499">      Object result = js.executeScript(FIND_SHADOW_ELEMENTS_FROM_ELEMENT_JS, root.getOriginal(), selector);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">      if (result instanceof java.util.List) {</span>
<span class="fc" id="L501">         return ((java.util.List&lt;WebElement&gt;) result).stream()</span>
<span class="fc" id="L502">               .map(webElement -&gt; new SmartWebElement(webElement, driver)).toList();</span>
      }
<span class="fc" id="L504">      return java.util.Collections.emptyList();</span>
   }

   /**
    * JavaScript function to find all matching elements starting from a given root element.
    * The script searches within the specified root element and its shadow DOM,
    * collecting all elements that match the given selector.
    *
    * &lt;p&gt;Supports standard Selenium locator types including ID, name, class, CSS selector,
    * tag name, link text, and partial link text. XPath is not supported.
    */
   private static final String FIND_SHADOW_ELEMENTS_FROM_ELEMENT_JS = &quot;&quot;&quot;
         function findShadowElementsFromRoot(rootElem, params) {
           const type = params.type;
           const value = params.value;
           const maxWait = params.maxWait || 10000;
           const pollInterval = params.pollInterval || 500;
         
           function collectInRoot(root, type, value) {
             let nodeList = [];
             switch (type) {
               case 'id':
                 let elById = root.querySelector('#' + value);
                 if (elById) nodeList.push(elById);
                 break;
               case 'name':
                 nodeList = root.querySelectorAll('[name=&quot;' + value + '&quot;]');
                 break;
               case 'className':
                 var classes = value.trim().split(/\\s+/).join('.');
                 nodeList = root.querySelectorAll('.' + classes);
                 break;
               case 'css':
                 nodeList = root.querySelectorAll(value);
                 break;
               case 'tagName':
                 nodeList = root.querySelectorAll(value);
                 break;
               case 'xpath':
                 let xres = document.evaluate(value, root, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                 for (let i = 0; i &lt; xres.snapshotLength; i++) {
                   nodeList.push(xres.snapshotItem(i));
                 }
                 break;
               case 'linkText':
                 let allAnchors = root.querySelectorAll('a');
                 allAnchors.forEach(a =&gt; { if (a.textContent === value) nodeList.push(a); });
                 break;
               case 'partialLinkText':
                 let anchors2 = root.querySelectorAll('a');
                 anchors2.forEach(a =&gt; { if (a.textContent.includes(value)) nodeList.push(a); });
                 break;
             }
             return Array.from(nodeList);
           }
         
           function collectShadow(rootNodes, type, value, results) {
             for (var i = 0; i &lt; rootNodes.length; i++) {
               var node = rootNodes[i];
               if (node &amp;&amp; node.shadowRoot) {
                 results.push(...collectInRoot(node.shadowRoot, type, value));
                 collectShadow(node.shadowRoot.querySelectorAll('*'), type, value, results);
               }
             }
           }
         
           function doSearch() {
             let found = [];
             // Check rootElem's shadow root
             if (rootElem.shadowRoot) {
               found.push(...collectInRoot(rootElem.shadowRoot, type, value));
               collectShadow(rootElem.shadowRoot.querySelectorAll('*'), type, value, found);
             }
             // Also treat rootElem as a normal DOM container
             found.push(...collectInRoot(rootElem, type, value));
             collectShadow(rootElem.querySelectorAll('*'), type, value, found);
             return found;
           }
         
           const startTime = performance.now();
           while ((performance.now() - startTime) &lt; maxWait) {
             let result = doSearch();
             if (result.length &gt; 0) {
               return result;
             }
             var now = performance.now();
             while (performance.now() - now &lt; pollInterval) {
               // busy wait
             }
           }
           return [];
         }
         return findShadowElementsFromRoot(arguments[0], arguments[1]);
         &quot;&quot;&quot;;

   /**
    * Checks whether there are elements with Shadow DOM in the current document.
    *
    * @param driver The {@link SmartWebDriver} instance.
    * @return True if Shadow DOM elements are present, otherwise false.
    */
   public static boolean shadowRootElementsPresent(SmartWebDriver driver) {
<span class="fc" id="L606">      JavascriptExecutor js = (JavascriptExecutor) driver.getOriginal();</span>
<span class="fc" id="L607">      String script =</span>
            &quot;return Array.from(document.querySelectorAll('*')).some(el =&gt; el.shadowRoot);&quot;;
<span class="fc" id="L609">      Object rawResult = js.executeScript(script);</span>

<span class="fc bfc" id="L611" title="All 2 branches covered.">      if (rawResult instanceof Boolean result) {</span>
<span class="fc" id="L612">         return result;</span>
      }

<span class="fc" id="L615">      return false;</span>
   }


   /**
    * Checks if there is at least one element that has a Shadow Root starting from a given WebElement.
    *
    * @param root The root {@link SmartWebElement} to check.
    * @return True if the root element or any descendant has a Shadow Root, otherwise false.
    */
   public static boolean shadowRootElementsPresent(SmartWebElement root) {
<span class="fc bfc" id="L626" title="All 2 branches covered.">      if (root</span>
            == null) {
<span class="fc" id="L628">         return false;</span>
      }
<span class="fc" id="L630">      WebDriver driver = root.getDriver();</span>
<span class="fc" id="L631">      JavascriptExecutor js = (JavascriptExecutor) driver;</span>

      // Check if the root itself has a shadowRoot or any of its descendants
<span class="fc" id="L634">      String script =</span>
            &quot;if (arguments[0].shadowRoot) { &quot;
                  + &quot;  return true; &quot;
                  + &quot;} else { &quot;
                  + &quot;  return Array.from(arguments[0].querySelectorAll('*')).some(el =&gt; el.shadowRoot);&quot;
                  + &quot;}&quot;;

<span class="fc" id="L641">      Object rawResult = js.executeScript(script, root.getOriginal());</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">      if (rawResult instanceof Boolean result) {</span>
<span class="fc" id="L644">         return result;</span>
      }

<span class="fc" id="L647">      return false;</span>
   }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>